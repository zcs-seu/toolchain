[[toc]]

# 要解决的问题

* 如何解决golang应用插件化

# 解决方案

## 插件使用的场景
- 可以热更新式扩展应用程序的功能列表
- 应对多变的业务需求，方便功能上下线
- 对于任意的go应用，能进行增量架构、代码分发以及代码上下线

## 插件设计标准
- 性能：调用插件要尽可能的快；对于任务插件，使用单独的工作空间（协程、线程、进程的池子化处理），大的、慢的、长期运行的插件，要少调用
- 稳定性：插件依赖的发布平台要少发布，交互API的设计要做好抽象，上下文的环境变量非必须不添加，减少升级需求，甚至能支持多个实例互备热升级
- 可靠性：如果有失效、崩溃的可能，必须有快速、简单、完整的恢复机制；业务插件的执行不能影响依赖的发布平台的守护进程或者线程的稳定
- 安全性：应该通过代码签名之类的手段防篡改
- 扩展性：支持插件热更新和上下线，下线需要健康检查，公共库插件至少能热加载
- 复用性：业务插件不要太多一次性的上下线
- 易用性：提供使用简单、功能正交的API，业务插件能够获取依赖的发布平台的上下文和调用公共库


#解决方案案例

## golang官方动态链接库plugin
官方背书,插件和主程序原生语法交互
使用样例:
 <<< @/../golang-pulgin-system/plugingo.go
 
 使用go build编译:
 ```$xslt
go build --buildmode=plugin -o pluginhello_v1.so  plugingo.go
```
ps: 注意：这里尤其要注意的是，plugin的源码需要在main包中，否则无法编译。
   
执行：
<<< @/../golang-pulgin-system/testPulgin.go

Go plugin判断两个插件是否相同是通过比较pluginpath实现的，如果没有指定pluginpath，则由内部的算法生成, 生成的格式为plugin/unnamed-“ + root.Package.Internal.BuildID 。这种情况下，如果两个插件的文件名不同，引用包不同，或者引用的cgo不同，则会生成不同的插件，同时加载不会有问题。但是如果两个插件的文件名相同，相关的引用包也相同，则可能生成相同的插件，即使插件内包含的方法和变量不同，实现也不同。判断插件相同，热加载不会成功，也就意味着老插件不支持覆盖更新。

最好在编译的指定pluginpath，同时方便版本跟踪。目前生产环境建议一些公共库无服务依赖的函数，例如算法库之类的。
```$xslt
go build -ldflags "-pluginpath=plugin/hot-$(date +%s)" -buildmode=plugin -o so/Eng.so eng/greeter.go
```

优缺点:
- 进程隔离：无，单进程
- 主程序调用插件：一切预协定object（包括function、channel）
- 插件感知主程序上下文：主程序预定义类型参数object（包括function、channel）
- stream支持：单向，基于channel
- 插件发现：主程序循环扫描插件目录并维护状态；通过第三方文件diff工具维护，例如git
- 上线：能
- 下线：不能
- 更新：不能
- 通信：进程内
- 序列化：不需要
- 性能：高

